# grep 命令中支持的正则表达式    

以下是常用的 grep 选项    

|选项|描述|
|-----|-----|
|-c |只输出匹配行的个数 |
|-i |不区分大小写（只适用于单字符） |
|-h |查询多文件时不显示文件名 |
|-l |查询多文件时只输出包含匹配字符的文件名 |
|-n |显示匹配行及行号 |
|-s |不显示不存在或无匹配文本的错误信息 |
|-v |显示不包含匹配文本的所有行 |
|-V |显示软件版本信息|
|-a |将 binary 文件以 text 文件的方式搜寻数据|
|-F |不使用正则表达式|

## 1. 正则表达式元字符集   

### 1.1 元字符集表    
|元字符集|描述|示例|
|-----|-----|------|
|`^` 		|锚定行的开始 |`^grep`匹配所有以grep开头的行  |
|`$` 		|锚定行的结束 |`grep$`匹配所有以grep结尾的行  |
|`.` 		|匹配一个非换行符的字符 |`gr.p`匹配gr后接一个任意字符，然后是p  |
|`*` 		|匹配零个或多个先前字符 |`*grep`匹配所有一个或多个空格后紧跟grep的行  `.*`一起用代表任意字符 |
|`[]` 		|匹配`一个`指定范围内的字符 |`[Gg]rep`匹配Grep和grep  |
|`[^]` 		|匹配一个不在指定范围内的字符 |`[^A-FH-Z]rep`匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行  |
|`\(..\)` 	|标记匹配字符 |`\(love\)`，love被标记为1  |
|`\` 		|锚定单词的开始 |`\`匹配包含以grep开头的单词的行  |
|`\>` 		|锚定单词的结束 |`grep\>`匹配包含以grep结尾的单词的行  |
|`x\{m\} `	|重复字符x，m次 |`0\{5\}`匹配包含5个o的行  |
|`x\{m,\} `	|重复字符x,至少m次 |`o\{5,\}`匹配至少有5个o的行  |
|`x\{m,n\}`	|重复字符x，至少m次，不多于n次 |`o\{5,10\}`匹配5--10个o的行 |
|`\w`		|匹配文字和数字字符，也就是[A-Za-z0-9]|`G\w*p`匹配以G后跟零个或多个文字或数字字符，然后是p |
|`\b` 		|单词锁定符 | `\bgrep\b`只匹配grep |

### 1.2 详细描述   
1.2.1 星号 `*`    
`*` 代表的是 `重复 0 个或多个前面的 RE 字符`， 因此，`o*`表示的是：拥有空字节或一个 `o` 以上的字符，因此，`grep -n "o*" test.txt` 将会匹配所有的字符.   
比如：`1122*`   
可能匹配的字符串有：`112、1122、1122222、1123131231 ......`.  
**疑问**: 为什么会有 112 被匹配到?又为什么 11 不能被匹配到?   
1.2.2 句号 `.`   
匹配除换行符之外的`任意一个`字符。   
比如：`112.`，将匹配`112`+`至少一个字符`   
可能匹配的字符串有：`1121、1122、112abc、1123131231 ......`，但不匹配`112`.  
**Note:** `.*`匹配匹配任意字符串。  
1.2.3 插入符号 `^`   
`^` 符号在方括号 [] `之内`与`之外`是不同的！ 在 `[] 内`代表`反向选择`，在 `[] 之外`则表示行首匹配！   
比如：`^abc`只匹配`行首`为 `abc` 的字符串.   
1.2.4 美元符 `$`    
在一个正则表达式的`末尾`，匹配一行的结尾。   
比如：`123$`，将只能匹配到`行尾`为 `123` 的字符行.    
**Note:** `^$` 匹配一个空行。   
1.2.5 方括号 `[]`   
匹配方括号内指定的字母集中的一个字符。其实 `[]` 里面不论有几个字符，它都仅代表某`一个`字符.   
比如：   
`[abc]`，将匹配字符 `a、b、c` 中的任意一个字符；   
`[^abc]`，将匹配除 `abc` 之外的所有字符。   
1.2.6 反斜线符号 `\`    
转义一个特殊的字符，使这个字符得到字面意义的解释。   
比如：`\$`，将表示它的字面字符 `$`； `\\`，表示 `\`。   
1.2.7 转义尖括号 `\<\>`  
用于标记单词边界。尖括号必须是转义的，否则它们只是字符的字面含义。  
比如：`\<the\>` 匹配 `the`，但不匹配 `them`，`there`。   
1.2.8 问号 `?`    
匹配 `0` 个或 `1` 个前面的字符，用于匹配单个字符。  
比如：`ab?c`，将匹配"ac"或"abc"。  
1.2.9 加号 `+`   
匹配`至少一个`前面的字符，它和星号 `*` 很相似，但它不匹配 `0` 个字符的情况。   
比如：`ab+c`将匹配`abc`，`abbc`，`abbb...c`等。    
1.2.10 转义波形括号 `\{\}`   
指示匹配前面正则表达式的次数。波形括号必须是转义的，否则只有字符的字面含义。用`\{n\}`表示 n 次，用`\{n,m\}`表示 (n-m) 次.   
比如：`[0-9]\{5\}`将匹配 `5` 位数字。    
1.2.11 圆括号 `()`   
包含一组正则表达式。与 `|` 或 `expr` 操作符一起使用。  
1.2.12 竖线 `|`    
正则表达式的 `或` 操作符匹配一组可选的字符。  
比如：`a(b|c)d` 将匹配 `abd` 或 `acd`。  
1.2.13 比较运算符 `=~`  
必须在 `[[   ]]` 里面(不推荐使用),可直接用支持正则的工具代替.
```bash
$ digit=132
$ [[ $digit =~ [0-9] ]]
$ echo $?
0  # 说明上边的表达式为真

$ digit="sfsfs"
$ [[ $digit =~ [0-9] ]]
$ echo $?
1  # 说明上边的表达式为假
```

## 2. 匹配的实例     
使用`grep`匹配时最好用双引号引起来，防止被系统误认为参数或者特殊命令，也可以匹配多个单词。   

|使用示例|作用|
|-----|-----|
|grep -c "48" test.txt 		|统计所有以“48”字符开头的行有多少|
|grep -i "May" test.txt 	|不区分大小写查找“May”所有的行|
|grep -n "48" test.txt 		|显示行号；显示匹配字符“48”的行及行号，相同于 nl test.txt |grep 48|
|grep -v "48" test.txt 		|显示输出没有字符“48”所有的行|
|grep "471" test.txt 		|显示输出字符“471”所在的行|
|grep "48;" test.txt 		|显示输出以字符“48”开头，并在字符“48”后是一个tab键所在的行|
|grep "48[34]" test.txt 	|显示输出以字符“48”开头，第三个字符是“3”或是“4”的所有的行|
|grep "[0-9]" test.txt 		|显示有一个数字的行|
|grep "t[ae]st" test.txt 	|显示『tast』或『test』两个字串|
|grep "[Mm]ay" test.txt 	|设置大小写查找：显示输出第一个字符以“M”或“m”开头，以字符“ay”结束的行|
|grep "K…D" test.txt 		|显示输出第一个字符是“K”，第二、三、四是任意字符，第五个字符是“D”所在的行|
|grep "[A-Z][9]D" test.txt  |显示输出第一个字符的范围是“A-D”，第二个字符是“9”，第三个字符的是“D”的所有的行|
|grep "[35]..1998" test.txt |显示第一个字符是3或5，第二三个字符是任意，以1998结尾的所有行|
|grep "4\{2,\}" test.txt 	|模式出现几率查找：显示输出字符“4”至少重复出现两次的所有行|
|grep "o\{3,\}" test.txt 	|模式出现几率查找：显示输出字符“o”至少重复出现三次的所有行|
|grep "9\{2,3\}" test.txt   |显示输出字符“9”重复出现的次数在 2次 或 3次 所有行|
|grep "China$" test.txt 	|显示行尾为 China 的所有行|
|grep "\.$" test.txt 	 	|显示行尾结束为小数点 (.) 的那一行, 小数点要使用转义字符(\)|
|grep "^the" test.txt 		|显示行首为 the 的所有行|
|grep "^[a-z]" test.txt 	|显示开头是小写字母的所有行|
|grep "^[^a-zA-Z]" test.txt |显示开头不是字母的所有行|
|grep "[^g]oo" test.txt 	|显示有 oo 的行，但不想要 oo 前面有 g, 注意是整行|
|grep "[^a-z]oo" test.txt 	|显示 oo 前面是小写字母的行, 如果要匹配数字与英文,就变成：[a-zA-Z0-9]|
|grep "^[^48]" test.txt 	|显示输出行首不是字符“48”的行, 第一个`^`表示行首, 第二个`^`表示否定|
|grep -n "^$" test.txt 		|显示输出空行的行号|
|ls -l |grep "^d" 			|如果要查询目录列表中的目录 同：`ls -d *`|
|ls -l |grep "^d[d]" 		|在一个目录中查询不包含目录的所有文件|
|ls -l |grpe "^d…..x..x" 	|查询其他用户和用户组成员有可执行权限的目录集合|

## 3. 扩展 grep   
grep -E 或者 egrep, 使用扩展 grep 的主要好处是增加了额外的正则表达式元字符集。   
3.1 打印所有包含NW或EA的行。如果不是使用egrep，而是grep，将不会有结果查出。   
```bash
egrep 'NW|EA' test.txt      

northwest       NW      Charles Main        3.0     .98     3       34
eastern         EA      TB Savage           4.4     .84     5       20
```
3.2 对于标准grep，如果在扩展元字符前面加\，grep会自动启用扩展选项-E。   
```bash
grep 'NW\|EA' testfile

northwest       NW      Charles Main        3.0     .98     3       34
eastern         EA      TB Savage           4.4     .84     5       20
```
3.3 搜索所有包含一个或多个3的行。   
```bash
egrep '3+' testfile
grep -E '3+' testfile
grep '3\+' testfile        

#这3条命令将会
northwest       NW      Charles Main          3.0     .98     3       34
western         WE      Sharon Gray           5.3     .97     5       23
northeast       NE      AM Main Jr.           5.1     .94     3       13
central         CT      Ann Stephens          5.7     .94     5       13
```
```bash
egrep '2\.?[0-9]' testfile 
grep -E '2\.?[0-9]' testfile
grep '2\.\?[0-9]' testfile 

#首先含有2字符，其后紧跟着0个或1个点，后面再是0和9之间的数字。
western         WE       Sharon Gray          5.3     .97     5       23
southwest       SW      Lewis Dalsass         2.7     .8      2       18
eastern         EA       TB Savage             4.4     .84     5       20
```
3.4 搜索一个或者多个连续的no的行。   
```bash
egrep '(no)+' testfile
grep -E '(no)+' testfile
grep '\(no\)\+' testfile   #3个命令返回相同结果，

northwest       NW      Charles Main        3.0     .98     3       34
northeast       NE       AM Main Jr.        5.1     .94     3       13
north           NO      Margot Weber        4.5     .89     5       9
``` 



在正则表达式中，如果直接给出字符，就是精确匹配。用\d可以匹配一个数字，\w可以匹配一个字母或数字，所以：

'00\d'可以匹配'007'，但无法匹配'00A'；

'\d\d\d'可以匹配'010'；

'\w\w\d'可以匹配'py3'；

.可以匹配任意字符，所以：

'py.'可以匹配'pyc'、'pyo'、'py!'等等。
要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：

来看一个复杂的例子：\d{3}\s+\d{3,8}。

我们来从左到右解读一下：

\d{3}表示匹配3个数字，例如'010'；

\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配' '，' '等；

\d{3,8}表示3-8个数字，例如'1234567'。

综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。

如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\'转义，所以，上面的正则是\d{3}\-\d{3,8}。

但是，仍然无法匹配'010 - 12345'，因为带有空格。所以我们需要更复杂的匹配方式。

进阶

要做更精确地匹配，可以用[]表示范围，比如：

[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；

[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'Py3000'等等；

[a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；

[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。

A|B可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'。

^表示行的开头，^\d表示必须以数字开头。

$表示行的结束，\d$表示必须以数字结束。

你可能注意到了，py也可以匹配'python'，但是加上^py$就变成了整行匹配，就只能匹配'py'了。